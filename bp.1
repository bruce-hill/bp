.\" Automatically generated by Pandoc 3.1.8
.\"
.TH "BP" "1" "May 17 2021" "" ""
.SH NAME
bp - Bruce\[aq]s Parsing Expression Grammar tool
.SH SYNOPSIS
\f[B]bp\f[R] [\f[I]options\&...\f[R]] \f[I]pattern\f[R] [[\f[B]--\f[R]]
\f[I]files\&...\f[R]]
.SH DESCRIPTION
\f[B]bp\f[R] is a tool that matches parsing expression grammars using a
custom syntax.
.SH OPTIONS
.TP
\f[I]pattern\f[R]
The text to search for.
The main argument for \f[B]bp\f[R] is a string literals which may
contain BP syntax patterns.
See the \f[B]STRING PATTERNS\f[R] section below.
.TP
\f[B]-w\f[R], \f[B]--word\f[R] \f[I]word\f[R]
Surround a string pattern with word boundaries (equivalent to \f[B]bp
\[aq]{|}word{|}\[aq]\f[R])
.TP
\f[B]-e\f[R], \f[B]--explain\f[R]
Print a visual explanation of the matches.
.TP
\f[B]-j\f[R], \f[B]--json\f[R]
Print a JSON list of the matches.
(Pairs with \f[B]--verbose\f[R] for more detail)
.TP
\f[B]-l\f[R], \f[B]--list-files\f[R]
Print only the names of files containing matches instead of the matches
themselves.
.TP
\f[B]-i\f[R], \f[B]--ignore-case\f[R]
Perform pattern matching case-insensitively.
.TP
\f[B]-I\f[R], \f[B]--inplace\f[R]
Perform filtering or replacement in-place (i.e.\ overwrite files with
new content).
.TP
\f[B]-r\f[R], \f[B]--replace\f[R] \f[I]replacement\f[R]
Replace all occurrences of the main pattern with the given string.
.TP
\f[B]-s\f[R], \f[B]--skip\f[R] \f[I]pattern\f[R]
While looking for matches, skip over \f[I]pattern\f[R] occurrences.
This can be useful for behavior like \f[B]bp -s string\f[R] (avoiding
matches inside string literals).
.TP
\f[B]-g\f[R], \f[B]--grammar\f[R] \f[I]grammar-file\f[R]
Load the grammar from the given file.
See the \f[B]GRAMMAR FILES\f[R] section for more info.
.TP
\f[B]-G\f[R], \f[B]--git\f[R]
Use \f[B]git\f[R] to get a list of files.
Remaining file arguments (if any) are passed to \f[B]git --ls-files\f[R]
instead of treated as literal files.
.TP
\f[B]-B\f[R], \f[B]--context-before\f[R] \f[I]N\f[R]
The number of lines of context to print before each match (default: 0).
See \f[B]--context\f[R] below for details on \f[B]none\f[R] or
\f[B]all\f[R].
.TP
\f[B]-A\f[R], \f[B]--context-after\f[R] \f[I]N\f[R]
The number of lines of context to print after each match (default: 0).
See \f[B]--context\f[R] below for details on \f[B]none\f[R] or
\f[B]all\f[R].
.TP
\f[B]-C\f[R], \f[B]--context\f[R] \f[I]N\f[R]
The number of lines to print before and after each match (default: 0).
If \f[I]N\f[R] is \f[B]none\f[R], print only the exact text of the
matches.
If \f[I]N\f[R] is \f[B]\[lq]all\[rq]\f[R], print all text before and
after each match.
.TP
\f[B]-f\f[R], \f[B]--format\f[R] \f[I]fancy\f[R]|\f[I]plain\f[R]|\f[I]bare\f[R]|\f[I]file:line\f[R]|\f[I]auto\f[R]
Set the output format.
\f[I]fancy\f[R] includes colors and line numbers, \f[I]plain\f[R] prints
line numbers with no coloring, \f[I]bare\f[R] prints only the match
text, \f[I]file:line\f[R] prints the filename and line number for each
match (grep-style), and \f[I]auto\f[R] (the default) uses
\f[I]fancy\f[R] formatting when the output is a TTY and \f[I]bare\f[R]
formatting otherwise.
.TP
\f[B]-h\f[R], \f[B]--help\f[R]
Print the usage and exit.
.TP
\f[I]files\&...\f[R]
The input files to search.
If no input files are provided and data was piped in, that data will be
used instead.
If neither are provided, \f[B]bp\f[R] will search through all files in
the current directory and its subdirectories (recursively).
.SH STRING PATTERNS
One of the most common use cases for pattern matching tools is matching
plain, literal strings, or strings that are primarily plain strings,
with one or two patterns.
\f[B]bp\f[R] is designed around this fact.
The default mode for bp patterns is \[lq]string pattern mode\[rq].
In string pattern mode, all characters are interpreted literally except
for curly braces \f[B]{}\f[R], which mark a region of BP syntax patterns
(see the \f[B]PATTERNS\f[R] section below).
In other words, when passing a search query to \f[B]bp\f[R], you do not
need to escape periods, quotation marks, backslashes, or any other
character, as long as it fits inside a shell string literal.
In order to match a literal \f[B]{\f[R], you can either search for the
character literal: \f[B]{\[ga]{}\f[R], the string literal:
\f[B]{\[dq]{\[dq]}\f[R], or a pair of matching curly braces using the
\f[B]braces\f[R] rule: \f[B]{braces}\f[R].
.SH PATTERNS
\f[B]bp\f[R] patterns are based off of a combination of Parsing
Expression Grammars and regular expression syntax.
The syntax is designed to map closely to verbal descriptions of the
patterns, and prefix operators are preferred over suffix operators (as
is common in regex syntax).
Patterns are whitespace-agnostic, so they work the same regardless of
whether whitespace is present or not, except for string literals
(\f[B]\[aq]...\[aq]\f[R] and \f[B]\[dq]...\[dq]\f[R]), character
literals (\f[B]\[ga]\f[R]), and escape sequences (\f[B]\[rs]\f[R]).
Whitespace between patterns or parts of a pattern should be used for
clarity, but it will not affect the meaning of the pattern.
.TP
\f[I]pat1 pat2\f[R]
A sequence: \f[I]pat1\f[R] followed by \f[I]pat2\f[R]
.TP
\f[I]pat1\f[R] \f[B]/\f[R] \f[I]pat2\f[R]
A choice: \f[I]pat1\f[R], or if it doesn\[aq]t match, then
\f[I]pat2\f[R]
.TP
\f[B].\f[R]
The period pattern matches single character (excluding newline)
.TP
\f[B]\[ha]\f[R]
Start of a line
.TP
\f[B]\[ha]\[ha]\f[R]
Start of the text
.TP
\f[B]$\f[R]
End of a line (does not include newline character)
.TP
\f[B]$$\f[R]
End of the text
.TP
\f[B]_\f[R]
Zero or more whitespace characters, including spaces and tabs, but not
newlines.
.TP
\f[B]__\f[R]
Zero or more whitespace characters, including spaces, tabs, newlines,
and comments.
Comments are undefined by default, but may be defined by a separate
grammar file.
See the \f[B]GRAMMAR FILES\f[R] section for more info.
.TP
\f[B]\[dq]foo\[dq]\f[R], \f[B]\[aq]foo\[aq]\f[R]
The literal string \f[B]\[lq]foo\[rq]\f[R].
Single and double quotes are treated the same.
Escape sequences are not allowed.
.TP
\f[B]\[ga]\f[R]\f[I]c\f[R]
The literal character \f[I]c\f[R] (e.g.\ \f[B]\[ga]\[at]\f[R] matches
the \[lq]\[at]\[rq] character)
.TP
\f[B]\[ga]\f[R]\f[I]c1\f[R]\f[B]-\f[R]\f[I]c2\f[R]
The character range \f[I]c1\f[R] to \f[I]c2\f[R]
(e.g.\ \f[B]\[ga]a-z\f[R]).
Multiple ranges can be combined with a comma
(e.g.\ \f[B]\[ga]a-z,A-Z\f[R]).
.TP
\f[B]\[ga]\f[R]\f[I]c1\f[R]\f[B],\f[R]\f[I]c2\f[R]
Any one of the given character or character ranges \f[I]c1\f[R] or
\f[I]c2\f[R] (e.g.\ \f[B]\[ga]a,e,i,o,u,0-9\f[R])
.TP
\f[B]\[rs]\f[R]\f[I]esc\f[R]
An escape sequence (e.g.\ \f[B]\[rs]n\f[R], \f[B]\[rs]x1F\f[R],
\f[B]\[rs]033\f[R], etc.)
.TP
\f[B]\[rs]\f[R]\f[I]esc1\f[R]\f[B]-\f[R]\f[I]esc2\f[R]
An escape sequence range from \f[I]esc1\f[R] to \f[I]esc2\f[R]
(e.g.\ \f[B]\[rs]x00-x1F\f[R])
.TP
\f[B]\[rs]\f[R]\f[I]esc1\f[R]\f[B],\f[R]\f[I]esc2\f[R]
Any one of the given escape sequences or ranges \f[I]esc1\f[R] or
\f[I]esc2\f[R] (e.g.\ \f[B]\[rs]r,n,x01-x04\f[R])
.TP
\f[B]\[rs]N\f[R]
A special escape that matches a \[lq]nodent\[rq]: one or more newlines
followed by the same indentation that occurs on the current line.
.TP
\f[B]\[rs]C\f[R]
A special escape that always matches the empty string and replaces it
with the indentation of the line on which it matched.
For example, this pattern would match Bash-style heredocs that start
with \[lq]<<-FOO\[rq] and end with a line containing only the starting
indentation and the string \[lq]FOO\[rq]: \f[B]\[dq]<<-\[dq]
\[at]end=(\[rs]C id) ..%\[rs]n (\[ha]end$)\f[R]
.TP
\f[B]\[rs]i\f[R]
An identifier character (e.g.\ alphanumeric characters or underscores).
.TP
\f[B]\[rs]I\f[R]
An identifier character, not including numbers (e.g.\ alphabetic
characters or underscores).
.TP
\f[B]|\f[R]
A word boundary (i.e.\ the edge of a word).
.TP
\f[B]\[rs]b\f[R]
Alias for \f[B]|\f[R] (word boundary)
.TP
\f[B](\f[R] \f[I]pat\f[R] \f[B])\f[R]
Parentheses can be used to delineate patterns, as in most languages.
.TP
\f[B]!\f[R] \f[I]pat\f[R]
Not \f[I]pat\f[R] (don\[cq]t match if \f[I]pat\f[R] matches here)
.TP
\f[B][\f[R] \f[I]pat\f[R] \f[B]]\f[R]
Maybe \f[I]pat\f[R] (match zero or one occurrences of \f[I]pat\f[R])
.TP
\f[I]N\f[R] \f[I]pat\f[R]
Exactly \f[I]N\f[R] repetitions of \f[I]pat\f[R] (e.g.\ \f[B]5
\[dq]x\[dq]\f[R] matches \f[B]\[lq]xxxxx\[rq]\f[R])
.TP
\f[I]N\f[R] \f[B]-\f[R] \f[I]M\f[R] \f[I]pat\f[R]
Between \f[I]N\f[R] and \f[I]M\f[R] repetitions of \f[I]pat\f[R]
(e.g.\ \f[B]2-3 \[dq]x\[dq]\f[R] matches \f[B]\[lq]xx\[rq]\f[R] or
\f[B]\[lq]xxx\[rq]\f[R])
.TP
\f[I]N\f[R]\f[B]+\f[R] \f[I]pat\f[R]
At least \f[I]N\f[R] or more repetitions of \f[I]pat\f[R] (e.g.\ \f[B]2+
\[dq]x\[dq]\f[R] matches \f[B]\[lq]xx\[rq]\f[R],
\f[B]\[lq]xxx\[rq]\f[R], \f[B]\[lq]xxxx\[rq]\f[R], etc.)
.TP
\f[B]*\f[R] \f[I]pat\f[R]
Any \f[I]pat\f[R]s (zero or more, e.g.\ \f[B]* \[dq]x\[dq]\f[R] matches
\f[B]\[lq]\[lq]\f[R], \f[B]\[rq]x\[rq]\f[R], \f[B]\[lq]xx\[rq]\f[R],
etc.)
.TP
\f[B]+\f[R] \f[I]pat\f[R]
Some \f[I]pat\f[R]s (one or more, e.g.\ \f[B]+ \[dq]x\[dq]\f[R] matches
\f[B]\[lq]x\[rq]\f[R], \f[B]\[lq]xx\[rq]\f[R], \f[B]\[lq]xxx\[rq]\f[R],
etc.)
.TP
\f[I]repeating-pat\f[R] \f[B]%\f[R] \f[I]sep\f[R]
\f[I]repeating-pat\f[R] (see the examples above) separated by
\f[I]sep\f[R] (e.g.\ \f[B]*word % \[dq],\[dq]\f[R] matches zero or more
comma-separated words)
.TP
\f[B]..\f[R] \f[I]pat\f[R]
Any text (except newlines) up to and including \f[I]pat\f[R].
This is a non-greedy match and does not span newlines.
.TP
\f[B].. %\f[R] \f[I]skip\f[R] \f[I]pat\f[R]
Any text (except newlines) up to and including \f[I]pat\f[R], skipping
over instances of \f[I]skip\f[R] (e.g.\ \f[B]\[aq]\[dq]\[aq]
\&..%(\[aq]\[rs]\[aq] .)
\[aq]\[dq]\[aq]\f[R] opening quote, up to closing quote, skipping over
backslash followed by a single character).
A useful application of the \f[B]%\f[R] operator is to skip over
newlines to perform multi-line matches, e.g.\ \f[B]pat1 ..%\[rs]n
pat2\f[R]
.TP
\f[B].. =\f[R] \f[I]only\f[R] \f[I]pat\f[R]
Any number of repetitions of the pattern \f[I]only\f[R] up to and
including \f[I]pat\f[R] (e.g.\ \f[B]\[dq]f\[dq] ..=abc \[dq]k\[dq]\f[R]
matches the letter \[lq]f\[rq] followed by some alphabetic characters
and then a \[lq]k\[rq], which would match \[lq]fork\[rq], but not
\[lq]free kit\[rq]) This is essentially a \[lq]non-greedy\[rq] version
of \f[B]*\f[R], and \f[B]..
pat\f[R] can be thought of as the special case of \f[B]..=.
pat\f[R]
.TP
\f[B]<\f[R] \f[I]pat\f[R]
Matches at the current position if \f[I]pat\f[R] matches immediately
before the current position (lookbehind).
\f[B]Note:\f[R] For fixed-length lookbehinds, this is quite efficient
(e.g.\ \f[B]<(100 \[dq]x\[dq])\f[R]), however this can cause performance
problems with variable-length lookbehinds (e.g.\ \f[B]<(\[dq]x\[dq]
0-100\[dq]y\[dq])\f[R]).
Also, patterns like \f[B]\[ha]\f[R], \f[B]\[ha]\[ha]\f[R], \f[B]$\f[R],
and \f[B]$$\f[R] that match against line/file edges will match against
the edge of the lookbehind window, so they should generally be avoided
in lookbehinds.
.TP
\f[B]>\f[R] \f[I]pat\f[R]
Matches \f[I]pat\f[R], but does not consume any input (lookahead).
.TP
\f[B]\[at]\f[R] \f[I]pat\f[R]
Capture \f[I]pat\f[R].
Captured patterns can be used in replacements.
.TP
\f[B]foo\f[R]
The named pattern whose name is \f[B]\[lq]foo\[rq]\f[R].
Pattern names come from definitions in grammar files or from named
captures.
Pattern names may contain dashes (\f[B]-\f[R]), but not underscores
(\f[B]_\f[R]), since the underscore is used to match whitespace.
See the \f[B]GRAMMAR FILES\f[R] section for more info.
.TP
\f[B]\[at]\f[R] \f[I]name\f[R] \f[B]:\f[R] \f[I]pat\f[R]
For the rest of the current chain, define \f[I]name\f[R] to match
whatever \f[I]pat\f[R] matches, i.e.\ a backreference.
For example, \f[B]\[at]my-word:word \[ga]( my-word \[ga])\f[R] (matches
\f[B]\[lq]asdf(asdf)\[rq]\f[R] or \f[B]\[lq]baz(baz)\[rq]\f[R], but not
\f[B]\[lq]foo(baz)\[rq]\f[R])
.TP
\f[B]\[at]\f[R] \f[I]name\f[R] \f[B]=\f[R] \f[I]pat\f[R]
Let \f[I]name\f[R] equal \f[I]pat\f[R] (named capture).
Named captures can be used in text replacements.
.TP
\f[I]pat\f[R] \f[B]=>\f[R] \f[B]\[dq]\f[R]\f[I]replacement\f[R]\f[B]\[dq]\f[R]
Replace \f[I]pat\f[R] with \f[I]replacement\f[R].
Note: \f[I]replacement\f[R] should be a string (single or double
quoted), and it may contain escape sequences (e.g.\ \f[B]\[rs]n\f[R]) or
references to captured values: \f[B]\[at]0\f[R] (the whole of
\f[I]pat\f[R]), \f[B]\[at]1\f[R] (the first capture in \f[I]pat\f[R]),
\f[B]\[at]\f[R]\f[I]foo\f[R] (the capture named \f[I]foo\f[R] in
\f[I]pat\f[R]), etc.
For example, \f[B]\[at]word _ \[at]rest=(*word % _) =>
\[dq]\[at]rest:\[rs]n\[rs]t\[at]1\[dq]\f[R] matches a word followed by
whitespace, followed by a series of words and replaces it with the
series of words, a colon, a newline, a tab, and then the first word.
.TP
\f[I]pat1\f[R] \f[B]\[ti]\f[R] \f[I]pat2\f[R]
Matches when \f[I]pat1\f[R] matches and \f[I]pat2\f[R] can be found
within the text of that match.
(e.g.\ \f[B]comment \[ti] \[dq]TODO\[dq]\f[R] matches comments that
contain \f[B]\[lq]TODO\[rq]\f[R])
.TP
\f[I]pat1\f[R] \f[B]!\[ti]\f[R] \f[I]pat2\f[R]
Matches when \f[I]pat1\f[R] matches, but \f[I]pat2\f[R] can not be found
within the text of that match.
(e.g.\ \f[B]comment \[ti] \[dq]IGNORE\[dq]\f[R] matches only comments
that do not contain \f[B]\[lq]IGNORE\[rq]\f[R])
.TP
\f[I]name\f[R]\f[B]:\f[R] \f[I]pat1\f[R]; \f[I]pat2\f[R]
Define \f[I]name\f[R] to mean \f[I]pat1\f[R] (pattern definition) inside
the pattern \f[I]pat2\f[R].
For example, a recursive pattern can be defined and used like this:
\f[B]paren-comment: \[dq](*\[dq] ..%paren-comment \[dq]*)\[dq];
paren-comment\f[R]
.TP
\f[B]\[at]:\f[R]\f[I]name\f[R] \f[B]=\f[R] \f[I]pat\f[R]
Match \f[I]pat\f[R] and tag it with the given name as metadata.
.TP
\f[I]name\f[R]\f[B]::\f[R] \f[I]pat\f[R]
Syntactic sugar for \f[I]name\f[R]\f[B]:\f[R]
\f[B]\[at]:\f[R]\f[I]name\f[R]\f[B]=\f[R]\f[I]pat\f[R] (define a pattern
that also attaches a metadata tag of the same name)
.TP
\f[B]#\f[R] \f[I]comment\f[R]
A line comment, ignored by BP
.SH GRAMMAR FILES
\f[B]bp\f[R] allows loading extra grammar files, which define patterns
which may be used for matching.
The \f[B]builtins\f[R] grammar file is loaded by default, and it defines
a few useful general-purpose patterns.
For example, it defines the \f[B]parens\f[R] rule, which matches pairs
of matching parentheses, accounting for nested inner parentheses:
.RS
.PP
\f[B]bp \[aq]my_func{parens}\[aq]\f[R]
.RE
.PP
BP\[cq]s builtin grammar file defines a few other commonly used patterns
such as:
.IP \[bu] 2
\f[B]braces\f[R] (matching \f[B]{}\f[R] pairs), \f[B]brackets\f[R]
(matching \f[B][]\f[R] pairs), \f[B]anglebraces\f[R] (matching
\f[B]<>\f[R] pairs)
.IP \[bu] 2
\f[B]string\f[R]: a single- or double-quote delimited string, including
standard escape sequences
.IP \[bu] 2
\f[B]id\f[R] or \f[B]var\f[R]: an identifier (full UTF-8 support)
.IP \[bu] 2
\f[B]word\f[R]: similar to \f[B]id\f[R]/\f[B]var\f[R], but can start
with a number
.IP \[bu] 2
\f[B]Hex\f[R], \f[B]hex\f[R], \f[B]HEX\f[R]: a mixed-case, lowercase, or
uppercase hex digit
.IP \[bu] 2
\f[B]digit\f[R]: a digit from 0-9
.IP \[bu] 2
\f[B]int\f[R]: one or more digits
.IP \[bu] 2
\f[B]number\f[R]: an int or floating point literal
.IP \[bu] 2
\f[B]esc\f[R], \f[B]tab\f[R], \f[B]nl\f[R], \f[B]cr\f[R],
\f[B]crlf\f[R], \f[B]lf\f[R]: Shorthand for escape sequences
.PP
\f[B]bp\f[R] also comes with a few grammar files for common programming
languages, which may be loaded on demand.
These grammar files are not comprehensive syntax definitions, but only
some common patterns.
For example, the c++ grammar file contains definitions for
\f[B]//\f[R]-style line comments as well as \f[B]/*...*/\f[R]-style
block comments.
Thus, you can find all comments with the word \[lq]TODO\[rq] with the
following command:
.RS
.PP
\f[B]bp -g c++ \[aq]{comment \[ti] \[dq]TODO\[dq]}\[aq] *.cpp\f[R]
.RE
.SH EXAMPLES
Find files containing the literal string \[lq]foo.baz\[rq] (a string
pattern):
.RS
.PP
\f[B]ls | bp foo.baz\f[R]
.RE
.PP
Find files ending with \[lq].c\[rq] and print the name with the
\[lq].c\[rq] replaced with \[lq].h\[rq]:
.RS
.PP
\f[B]ls | bp \[aq].c{$}\[aq] -r \[aq].h\[aq]\f[R]
.RE
.PP
Find the word \[lq]foobar\[rq], followed by a pair of matching
parentheses in the file \f[I]my_file.py\f[R]:
.RS
.PP
\f[B]bp \[aq]foobar{parens}\[aq] my_file.py\f[R]
.RE
.PP
Using the \f[I]html\f[R] grammar, find all \f[I]element\f[R]s matching
the tag \f[I]a\f[R] in the file \f[I]foo.html\f[R]:
.RS
.PP
\f[B]bp -g html \[aq]{element \[ti] (\[ha]\[ha]\[dq]<a \[dq])}\[aq]
foo.html\f[R]
.RE
.SH AUTHORS
Bruce Hill (\f[I]bruce\[at]bruce-hill.com\f[R]).
